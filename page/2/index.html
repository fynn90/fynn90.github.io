<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/atom.xml" title="Fynn's Blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1.2" />



<link rel="canonical" href="https://fynn90.github.io/page/2/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="Fynn&#39;s Blog">
<meta property="og:url" content="https://fynn90.github.io/page/2/index.html">
<meta property="og:site_name" content="Fynn&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fynn">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1.2" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?607980a031d3edcefed502ce80e77ffb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-115728733-1', 'auto');
        ga('send', 'pageview');
  </script>



    <title> Fynn's Blog </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Fynn's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Fynn's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/10/11/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E5%9B%BE%E8%B0%B1/">算法知识学习图谱</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年10月11日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>算法知识学习图谱,内容按照下面👇<a target="_blank" rel="noopener" href="https://naotu.baidu.com/file/0a53d3a5343bd86375f348b2831d3610?token=5ab1de1c90d5f3ec">图片</a>设计</p>
<p><img src="https://ae01.alicdn.com/kf/H4526e15fce37491e91935ab0936881e3c.png"></p>
          <div class="read-more">
            <a href="/2019/10/11/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E5%9B%BE%E8%B0%B1/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">数据结构知识图谱</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年10月10日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>该文档用于记录数据结构一些知识点和它的解释.记录的内容是按下面<a target="_blank" rel="noopener" href="https://naotu.baidu.com/file/b832f043e2ead159d584cca4efb19703?token=7a6a56eb2630548c">图片</a>表示而来👇<img src="https://i.loli.net/2019/10/09/5DpGHnduYBWjQPy.png" alt="脑图"></p>
          <div class="read-more">
            <a href="/2019/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/09/18/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%8A)/">十大经典排序算法(上)</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年9月18日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>算法是计算机世界永恒的主题,现在世界其实是被算法驱动着进步.学习算法并能熟练在自己业务场景中应用各种算法应该是每个程序员必备的素质.从最基础的十大经典排序算法作为开始,开启自己系统学习算法之路!</p>
<h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ul>
<li>冒泡排序只会操作相邻的两个元素</li>
<li>每次冒泡操作都会对相邻的两个元素进行比较,看是否满足大小关系要求.如果不满足就让它们俩互换.</li>
<li>冒泡排序算法最多进行 n-1次(n 排序数组长度),每次算法执行元素对比次数是n - i -1次(n 排序数组长度, i 当前算法循环次数)</li>
</ul>
<p><img src="https://i.loli.net/2019/09/15/ZKfk8jYn5VOP6xr.gif" alt="4208590040-5ac42b210af83_articlex.gif"></p>
<p><img src="https://image-static.segmentfault.com/116/807/116807884-57dcd3a8c4bf4_articlex" alt="116807884-57dcd3a8c4bf4_articlex.gif"></p>
          <div class="read-more">
            <a href="/2019/09/18/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%8A)/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/09/13/JS_Proxy_and_Reflect/">Proxy、Reflect</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年9月13日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>从<a target="_blank" rel="noopener" href="https://tc39.es/ecma262/#sec-reflection">ECMAScript2015</a>开始,JavaScript新增了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a>对象.通过这两个对象你可以拦截并自定义语言原来的操作行为(例如:属性查找、赋值、枚举、函数调用等).借助这两个对象你可以在JavaScript进行元级别进行编程(<a href="%5Bhttps://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B%5D(https://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B)">元编程</a>).</p>
          <div class="read-more">
            <a href="/2019/09/13/JS_Proxy_and_Reflect/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/">面向对象设计模式原则</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年9月12日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>设计模式（Design Patterns）：维护、扩展代码的组织形式。它是开发人员对于代码组织方式的总结，每一种设计模式都是针对不同的代码逻辑场景提出最优的代码组织方式。</p>
<p>每个设计模式都会遵循一个或多个设计原则，这些原则有：</p>
<ol>
<li>单一职责原则（Single Responsibility Principle, SRP）</li>
<li>开闭原则（Open Closed Principle，OCP）</li>
<li>里氏代换原则（Liskov Substitution Principle，LSP）</li>
<li>接口隔离原则（Interface Segregation Principle，ISP）</li>
<li>依赖倒转原则（Dependency Inversion Principle，DIP）</li>
<li>迪米特法则（Law of Demeter，LOD）</li>
<li>合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）</li>
</ol>
<table>
<thead>
<tr>
<th align="center">标记</th>
<th align="center">设计模式原则名称</th>
<th align="center">简单定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SRP</td>
<td align="center">单一职责原则</td>
<td align="center">一个类只负责一个功能领域中的相应职责</td>
</tr>
<tr>
<td align="center">OCP</td>
<td align="center">开闭原则</td>
<td align="center">对扩展开放，对修改关闭</td>
</tr>
<tr>
<td align="center">LSP</td>
<td align="center">里氏代换原则</td>
<td align="center">所有引用基类的地方必须能透明地使用其子类的对象</td>
</tr>
<tr>
<td align="center">ISP</td>
<td align="center">接口隔离原则</td>
<td align="center">类之间的依赖关系应该建立在最小的接口上</td>
</tr>
<tr>
<td align="center">DIP</td>
<td align="center">依赖倒转原则</td>
<td align="center">依赖于抽象，不能依赖于具体实现</td>
</tr>
<tr>
<td align="center">LOD</td>
<td align="center">迪米特法则</td>
<td align="center">一个软件实体应当尽可能少的与其他实体发生相互作用</td>
</tr>
<tr>
<td align="center">CARP</td>
<td align="center">合成/聚合复用原则</td>
<td align="center">尽量使用合成/聚合，而不是通过继承达到复用的目的</td>
</tr>
</tbody></table>
<p><em>单一职责原则_、_开闭原则_、_里氏代换原则_、_接口隔离原则</em> 和<em>依赖倒转原则</em> 就是我们平常熟知的<strong>SOLID</strong>。</p>
          <div class="read-more">
            <a href="/2019/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/09/10/Object.defineProperty/">Object.defineProperty</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年9月10日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p><code>Object.defineProperty</code>可以用来给<code>Object</code>增加新的属性或更新已有属性,并返回该<code>Object</code>.</p>
<p><code>Object.defineProperty</code>并不单单只是让我们手动给<code>Object</code>添加或修改属性值,它最大的特点是我们可以给对象单个属性值添加属性描述符(PropertyDescriptor).</p>
<p>属性描述符可以给当前对象属性添加额外的一些功能,例如:是否可以被修改、是否可以被枚举、捕获该属性的值的变化和读取.</p>
<p><em>注意: 冻结一个对象属性操作可以用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"><code>Object.freeze()</code></a></em></p>
<p><em>注意: 可以用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">Object.defineProperties</a>批量给对象添加或修改属性描述符</em></p>
          <div class="read-more">
            <a href="/2019/09/10/Object.defineProperty/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/09/09/window.requestAnimationFrame/">requestAnimationFrame</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年9月9日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>在制作页面动画时,我们可以通过定时器(<code>setTimeout</code>或<code>setInterval</code>)循环操作DOM节点来实现动画的效果.</p>
<p>但是<a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution?hl=zh-tw">Google 最佳JS实践</a>要求使用<code>requestAnimationFrame</code>代替定时器.这是为什么呢?</p>
<p>原因有三个:</p>
<ol>
<li><code>setTimeout\setInterval</code>并不和JS在一个线程上,虽然你可以模拟浏览器刷新频率(1000/60),但如果JS线程执行时间较长,JS出超过这个时间去保存有<code>setTimeout\setInterval</code>回调的队列中拿回调执行.这个时候页面会出现卡顿的情况.</li>
<li>在一些浏览器中,运行有<code>setTimeout\setInterval</code>的脚本的页面,即使当前未被打开,定时器脚本依然是在后台运行的.这就浪费了计算机资源.</li>
<li>并不是所有的浏览器都是每秒60帧频率,所以<code>setTimeout\setInterval</code>的定时时间需要适配设备.</li>
</ol>
<p>用<code>requestAnimationFrame</code>就不会有上面这三个问题!</p>
          <div class="read-more">
            <a href="/2019/09/09/window.requestAnimationFrame/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/">设计模式-状态模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年9月2日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>状态模式是一种行为软件设计模式.一个对象在其内部状态改变时会改变它的行为.各种状态和状态改变行为的操作是被独立封装的..</p>
<p>一般情况是:如果一个事物有多钟状态,我们用一个变量保存当前状态名(string),通过<code>if-else</code> 做状态的判断,然后进行状态的变更.</p>
<p>这样最大的问题是: 你需要将所有的状态和变更状态后的行为都放在一个方法里.这个方法会变得很臃肿和复杂.会变的难以阅读和维护.</p>
<p>状态模式:将各种状态和状态之间切换的行为封装在一起.只需要一个Context来触发状态变化,而状态变化后引起的行为操作Context不用处理.</p>
<p>状态模式的优点:</p>
<ol>
<li>状态和行为关系封装在一起,增加新的状态和状态转换会很容易</li>
<li>对象代替字符串保存当前状态,状态的可切换一目了然</li>
<li>避免了Context无限膨胀</li>
<li>Context中的请求动作和状态类中封装的行为非常容易,它们独立变化而不互相影响</li>
</ol>
<p>状态模式的缺陷:</p>
<ol>
<li>逻辑分散在状态类中,虽然避免的条件分支但也导致了逻辑分散问题</li>
<li>新增了封装状态和行为变化的对象,增加了代码量.</li>
</ol>
          <div class="read-more">
            <a href="/2019/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式-装饰者模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年8月25日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>饰模式是种动态的向一个类(方法)添加行为的设计模式.它不会直接修改原类(方法).</p>
<p>装饰模式比生成子类更灵活,它不会影响原来的类(方法),可以增对单独的方法增加新的行为.</p>
<blockquote>
<p>在面向对象的编程中，装饰器模式是一种设计模式，它允许将行为静态或动态地添加到单个对象，而不会影响同一类中其他对象的行为。装饰器模式通常用于遵守单一责任原则，因为它允许在具有独特关注区域的类之间划分功能。</p>
</blockquote>
          <div class="read-more">
            <a href="/2019/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/">设计模式-职责链模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年8月23日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>职责链模式是一种行为型设计模式,它将一些列可能会处理请求的对象连接成在一起,请求在这些对象间传递,直到遇到可以处理它的对象.这些处理请求的对象称为链中的节点.</p>
<p>职责链模式优点:</p>
<ul>
<li>解耦请求的发送者和N个接受者之间复杂关系.</li>
<li>手动指定起始节点.</li>
<li>链中的节点对象可以灵活拆分重组.</li>
</ul>
<p><strong>注意:</strong> 职责链模式有个缺陷是,大部分的节点并没有实质的作用,它们的作用仅仅是让请求传递下去,从性能方面考虑我们要避免过长的职责链带来的性能消耗.</p>
<p>职责链模式可以很好地帮助我们管理代码,降低发起请求的对象和处理请求对象之间的耦合性.</p>
<p><img src="https://i.loli.net/2019/08/22/LxpzCP1cETB9SnX.png" alt="5bd5b48157043.png"></p>
          <div class="read-more">
            <a href="/2019/08/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式-中介者模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年8月22日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>中介者模式是一种行为型设计模式,它的目的是通过增加一个中介对象,解除对象与对象之间的紧耦合关系.</p>
<p>增加中介对象后,所有的相关对象都通过中介对象来通信,而不是互相引用,所有当一个对象发生改变时,只需要通知中介者对象即可.</p>
<p><img src="https://i.loli.net/2019/08/22/N9zC85GOMHRdxnl.png" alt="mediator-pattern22.png"></p>
          <div class="read-more">
            <a href="/2019/08/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">设计模式-享元模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年8月20日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>享元模式(Flyweight)是一种软件设计模式.是通过将类似的对象进行共享,达到最小化内存的使用对象.</p>
<p>享元模式要求将对象的属性划分为内部状态(不会改变属性)和外部状态(会动态变化的属性).享元模式的目标是尽量减少共享对象的数量.它的关键点是划分内部状态和外部状态.</p>
<p>享元模式特点:</p>
<ul>
<li>内部状态存储于对象内部</li>
<li>内部状态可以被一些对象共享</li>
<li>内部状态独立于具体的场景,通常不会变化</li>
<li>外部状态取决于具体的场景,并根据场景而变化,外部状态不会被共享.</li>
</ul>
<p><strong>注意:</strong> 享元模式是一种用时间换空间的优化模式.</p>
          <div class="read-more">
            <a href="/2019/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">设计模式-模板方法模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年8月19日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>模板方法模式是一种行为设计模式,它是需要通过继承实现的设计模式.</p>
<p>模板方法模式有两个部分组成.</p>
<ol>
<li>抽象父类.它定义了算法操作框架和具体的算法执行流程.(一般在父类定义 init 方法作执行算法)</li>
<li>具体实现抽象父类的子类. 子类实现了父类定义的算法结构,但最后的执行通过父类实现的方法执行.</li>
</ol>
<p><strong>注意:</strong> 父类只负责定义算法框架,具体实现有子类完成.不同的子类,实现抽象类定义的抽象方法可以不同,但子类不应该改变算法的执行步骤!</p>
          <div class="read-more">
            <a href="/2019/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">设计模式-适配器模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年8月19日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>适配器模式是一种很简单的软件设计模式,它允许将现有的类(方法)用作另一个接口.它通常用于使现有类(方法)与其他类(方法)一起工作而无需修改其源码.</p>
<p>适配器模式看起和装饰者模式、代理模式看起来很像.但它们在设计目的上还是有不同的:</p>
<ul>
<li>适配器模式主要是用来解决两个已有接口之间不匹配的问题,它不考虑这些接口具体的实现,也不考虑它们将如何演化.适配器不需要改变已有的接口,就能够使它们协同作用.</li>
<li>装饰者模式和代理模式也不会改变原有对象的接口,但装饰者模式的作用是为了给对象增加功能.代理模式是为了控制对象的访问,通常也只包装一次.</li>
</ul>
          <div class="read-more">
            <a href="/2019/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">设计模式-组合模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年8月16日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>组合模式是一种结构型设计模式,组合模式将对象以树形结构组合在一起,每一个对象具有相同的属性和方法.组合模式允许客户用统一的方式处理单个对象.</p>
<p>组合模式的特点:</p>
<ol>
<li>表示树形结构.可以非常方便描述对象部分-整体层次结构.</li>
<li>利用对象多态性统一对待组合对象和单个对象.在组合模式中,使用者将统一地使用组合结构中的所有对象,而不用关心它究竟是组合对象还是单个对象.</li>
</ol>
          <div class="read-more">
            <a href="/2019/08/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">设计模式-命令模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年8月15日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>命令模式(Command pattern)是一种行为设计模式,它封装的对象包含稍后执行所需要的方法名和该方法需要的参数.</p>
<p>命令对象发送者和接受者并不知道彼此,他们也不关心.这样就将可以消除的发送者和接受者之间的耦合关系.</p>
<p>命令模式带来的好处有:</p>
<ol>
<li>重复多次操作(例如:重复下单)</li>
<li>取消操作(例如:下的订单取消掉)</li>
<li>取消后重做操作(例如:订单的支付取消,然后再进行支付)</li>
<li>操作行为回溯(例如:象棋中的悔棋操作)
          <div class="read-more">
            <a href="/2019/08/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83_%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">设计模式-发布-订阅模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年8月6日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <blockquote>
<p>发布-订阅模式.又称观察者模式(Observer).它定义了对象之间的一对一或一对多的依赖关系.当一个对象发生变化时,它会通知到依赖它的其他对象.</p>
</blockquote>
<p>发布-订阅模式广泛用于异步编程者中,是一种代替传递回调函数的方案.前端最典型的例子就是:<code>EventTarget.addEventListener()</code>监听DOM事件.</p>
<p>发布-订阅模式可以取代对象之间的硬编码,让两个对象松耦合联系在一起.</p>
<p>发布订阅模式的缺陷:</p>
<ol>
<li>会消耗一定的时间和内存.</li>
<li>过度使用会将对象之间的联系深埋在背后,导致程序难以跟踪维护和理解.
          <div class="read-more">
            <a href="/2019/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83_%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">设计模式-代理模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年8月4日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <blockquote>
<p>代理模式:通过一个中间对象,控制对真实想要调用对象的访问.</p>
</blockquote>
<p>代理模式的用途:</p>
<ol>
<li>代理将接受的信息 加工处理后传给本体,还可以控制本体接受数据的速率.</li>
<li>代理帮助缓存本体已经处理过的数据.</li>
<li>代理校验是否有权限访问本体.</li>
</ol>
          <div class="read-more">
            <a href="/2019/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/07/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">设计模式-策略模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年7月27日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>软件设计模式是高效组织代码的方式,它能保证系统的灵活性和可靠性.策略模式是最长用的模式之一.</p>
<blockquote>
<p>定义一系列的算法,把它们封装起来.并且使它们可以互相替换. - 策略模式</p>
</blockquote>
          <div class="read-more">
            <a href="/2019/07/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/07/17/Node.JS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/">Node.JS自动打包部署脚本</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019年7月17日
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>前端工程化的一个基础能力就是自动部署前端打包后的代码到服务器.基于node和typecript写了一个自动部署的脚步.</p>
<p>脚本的逻辑是先将目录打包压缩包,再通过SSH上传到服务器,最后解压和备份.<a target="_blank" rel="noopener" href="https://github.com/fynn90/node-deploy-script">源码地址</a></p>
<p><img src="https://i.loli.net/2019/07/17/5d2ef632b8e1f76645.png" alt="图片"></p>
          <div class="read-more">
            <a href="/2019/07/17/Node.JS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/3/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:fynn.90@outlook.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/%E5%B8%86-%E9%82%93-17163589/" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
        
          <a target="_blank" rel="noopener" href="https://plus.google.com/u/0/117459332873536225443" class="iconfont icon-google" title="google"></a>
        
      
    
      
        
          <a target="_blank" rel="noopener" href="https://github.com/fatefan" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a target="_blank" rel="noopener" href="http://www.weibo.com/306019091" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
        
          <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/FynnDeng/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
    
    
  </div>


<div class="copyright">
  
  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2021

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Fynn</span>
  </span>
  
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=1.1.2"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1.2"></script>

    
  </body>
</html>
