<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Nginx入门指南"/>




  <meta name="keywords" content="Nginx, Fynn's Blog" />










  <link rel="alternate" href="/atom.xml" title="Fynn's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="https://fynn90.github.io/2017/12/25/Nginx入门指南/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?607980a031d3edcefed502ce80e77ffb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <script id="google_analytics">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-115728733-1', 'auto');
        ga('send', 'pageview');
  </script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "jH321kB4p1r5FNrL8YBCwbrG-gzGzoHsz",
      appKey: "Q8vnaBtTzmVPbVX8tdzM7z7w"
    });
  </script>





    <title> Nginx入门指南 - Fynn's Blog </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Fynn's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/categories/">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Fynn's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            
            
              分类
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Nginx入门指南
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-25
        </span>
        
          <div class="post-category">
            
              <a href="/categories/OA/">OA</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2017/12/25/Nginx入门指南/"
             data-title="Nginx入门指南">
            阅读次数
          </div>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#特点"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安装"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命令"><span class="toc-text">命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置文件"><span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指令上下文"><span class="toc-text">指令上下文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gzip"><span class="toc-text">gzip</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ngx-http-gzip-module"><span class="toc-text">ngx_http_gzip_module</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip-1"><span class="toc-text">gzip;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gizp-buffers"><span class="toc-text">gizp_buffers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip-comp-level"><span class="toc-text">gzip_comp_level</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip-disable"><span class="toc-text">gzip_disable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip-min-length"><span class="toc-text">gzip_min_length</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip-http-version"><span class="toc-text">gzip_http_version</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip-proxied"><span class="toc-text">gzip_proxied</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip-types"><span class="toc-text">gzip_types</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip-vary"><span class="toc-text">gzip_vary</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ngx-http-gzip-static-module"><span class="toc-text">ngx_http_gzip_static_module</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip-static"><span class="toc-text">gzip_static</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例子"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟服务器"><span class="toc-text">虚拟服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#location"><span class="toc-text">location</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#root"><span class="toc-text">root</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#返回指定状态码"><span class="toc-text">返回指定状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#return"><span class="toc-text">return</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URI重写"><span class="toc-text">URI重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理错误"><span class="toc-text">处理错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反向代理"><span class="toc-text">反向代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-pass"><span class="toc-text">proxy_pass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-http-version"><span class="toc-text">proxy_http_version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-set-header"><span class="toc-text">proxy_set_header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-buffers"><span class="toc-text">proxy_buffers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-buffer-size"><span class="toc-text">proxy_buffer_size</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#负载均衡"><span class="toc-text">负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#upstream"><span class="toc-text">upstream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#server"><span class="toc-text">server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ip-hash"><span class="toc-text">ip_hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#least-conn"><span class="toc-text">least_conn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#least-time"><span class="toc-text">least_time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash"><span class="toc-text">hash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态内容服务"><span class="toc-text">静态内容服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#root-1"><span class="toc-text">root</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-file"><span class="toc-text">try_file</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#autoindex"><span class="toc-text">autoindex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendfile"><span class="toc-text">sendfile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendfile-max-chunk"><span class="toc-text">sendfile_max_chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-nopush"><span class="toc-text">tcp_nopush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-nodelay"><span class="toc-text">tcp_nodelay</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化Backlog-队列"><span class="toc-text">优化Backlog 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#查看-Listen-队列"><span class="toc-text">查看 Listen 队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FreeBSD"><span class="toc-text">FreeBSD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置NGINX"><span class="toc-text">配置NGINX</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#日志管理"><span class="toc-text">日志管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#日志分析工具-goaccess"><span class="toc-text">日志分析工具 goaccess</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#安装-1"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用"><span class="toc-text">使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#日志切割"><span class="toc-text">日志切割</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在线升级-编译模块"><span class="toc-text">在线升级/编译模块</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p><img src="https://nginx.org/nginx.png" alt="">  </p>
<p><a href="https://nginx.org/en/" target="_blank" rel="noopener">Nginx</a> [ engine x] 是一款<strong>HTTP请求服务器</strong>和<strong>反向代理服务器</strong>，它还是<strong>邮件代理服务器</strong>和一个通用的<strong>TCP/UDP代理服务器</strong>。它是有俄罗斯人<a href="http://sysoev.ru/en/" target="_blank" rel="noopener">Igor Sysoev</a>开发。</p>
<p>Nginx主要用于Web服务、反向代理或负载均衡服务、前端业务数据缓存服务。<br><a id="more"></a>  </p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Nginx模块化架构，以事件驱动的方式编写，拥有非常好的性能，同时也是个非常高效的反向代理、负载均衡服务器。</p>
<p>基础的HTTP服务特点：</p>
<ol>
<li>提供静态和索引<a href="https://nginx.org/en/docs/http/ngx_http_index_module.html" target="_blank" rel="noopener">文件</a>，<a href="https://nginx.org/en/docs/http/ngx_http_autoindex_module.html" target="_blank" rel="noopener">自动索引</a>，<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#open_file_cache" target="_blank" rel="noopener">文件缓存</a>。</li>
<li>[反向代理]加速(<a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html)及数据缓存。" target="_blank" rel="noopener">https://nginx.org/en/docs/http/ngx_http_proxy_module.html)及数据缓存。</a></li>
<li><a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html" target="_blank" rel="noopener">负载均衡和容错</a>。</li>
<li>支持高速缓存<a href="https://nginx.org/en/docs/http/ngx_http_fastcgi_module.html" target="_blank" rel="noopener">FastCGI</a>、<a href="https://nginx.org/en/docs/http/ngx_http_uwsgi_module.html" target="_blank" rel="noopener">uwsgi</a>、<a href="https://nginx.org/en/docs/http/ngx_http_scgi_module.html" target="_blank" rel="noopener">SCGI</a>和<a href="https://nginx.org/en/docs/http/ngx_http_memcached_module.html" target="_blank" rel="noopener">memcached</a>。</li>
<li>支持<a href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html" target="_blank" rel="noopener">SSL</a>TLS、 SNI。</li>
<li>支持<a href="https://nginx.org/en/docs/http/ngx_http_v2_module.html" target="_blank" rel="noopener">HTTP/2</a>。</li>
<li>支持 3xx-5xxHTTP状态码重定向</li>
<li>支持rewrite模块，支持URI重写及正则表达式匹配。</li>
<li>支持基于客户端IP地址和HTTP基本认证访问控制。</li>
<li>支持同一IP地址的并发连接和请求数限制。</li>
</ol>
<p>Nginx采用一个主（master）进程和多个工作(worker)进程架构模式。</p>
<p><img src="http://tengine.taobao.org/book/_images/chapter-2-1.PNG" alt=""><br>master进程用于管理worker进程。当worker进程退出或异常，会自动重启新的worker进程。</p>
<p>因为这个架构Nginx可以不中断服务的进行重启和升级。<br>支持高并发，资源消耗小，可以做HTTP反向代理及加速缓存，Nginx已经成为现在服务器首选。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Nginx 支持windows 和 Linux平台。<br>linux安装Nginx之前需要安装它的依赖包：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install pcre pcre-devel -y</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rpm -qa pcre pcre-devel</span></span><br></pre></td></tr></table></figure></p>
<p><strong>pcre</strong> 全称perl compatible regular expressions(perl兼容正则表达式)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install -y openssl openssl-devel</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rpm -qa openssl openssl-devel</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget -q https://nginx.org/download/nginx-1.12.2.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -xf nginx-1.12.2.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> nginx-1.12.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure \ </span></span><br><span class="line">--prefix=/application/nginx-1.12.2    \</span><br><span class="line">--sbin-path=/usr/sbin/nginx           \</span><br><span class="line">--conf-path=/application/nginx-1.12.2/nginx.conf     \</span><br><span class="line">--pid-path=/var/run/nginx.pid         \</span><br><span class="line">--lock-path=/var/run/nginx.lock       \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module        \</span><br><span class="line">--with-http_stub_status_module        \</span><br><span class="line">--with-http_ssl_module                \</span><br><span class="line">--with-pcre                           \</span><br><span class="line">--with-file-aio                       \</span><br><span class="line">--with-http_realip_module             \</span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s /application/nginx-1.12.2 /application/nginx</span></span><br></pre></td></tr></table></figure>
<p><a href="https://nginx.org/en/docs/configure.html" target="_blank" rel="noopener">Nginx配置</a>有几十个选项。<code>--with-xx-xx</code>表示默认是不启用的，在配置时加入表示启用。<code>--without-xx-xx</code>默认是启用的配置，在配置时加上表示禁止启用。<br>·<br>创建 service<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=The NGINX HTTP and reverse proxy server</span><br><span class="line"><span class="attr">After</span>=syslog.target network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=forking</span><br><span class="line"><span class="attr">PIDFile</span>=/run/nginx.pid</span><br><span class="line"><span class="attr">ExecStartPre</span>=/usr/sbin/nginx -t</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/sbin/nginx</span><br><span class="line"><span class="attr">ExecReload</span>=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">ExecStop</span>=/bin/kill -s QUIT <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">PrivateTmp</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>文件名为<strong>ngxin.service</strong>， 存放路径：<code>/usr/lib/systemd/system/nginx.service</code><br>执行下面命令将<strong>nginx</strong> 启动并添加到开机启动：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start nginx.service</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> nginx.service</span></span><br></pre></td></tr></table></figure></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>重新加载配置文件，你可以停止或重启NGINX，或者发信号给主进程。<br>一个信号可以通过nginx命令行发送（调用NGINX可执行文件）使用 <code>-s</code> 作为参数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s signal</span><br></pre></td></tr></table></figure></p>
<p>这个<code>signal</code>值可以是下面这些：</p>
<ul>
<li>quit – 温和停止</li>
<li>reload – 重新加载配置文件</li>
<li>reopen – 打开日志文件</li>
<li>stop – 立刻停止</li>
</ul>
<p>你也可以通过<code>kill</code>命令给主进程发送信号。进程ID是被写进<strong>nginx.pid</strong> 文件中。默认地址<code>/usr/local/nginx/logs</code>或者<code>/var/run</code>目录中。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>NGINX是有个个模块组成，每个模块实现特定的功能。将这些模块组织在一起就是通过配置文件。NGINX默认配置文件文件名为 <strong>nginx.conf</strong> 。</p>
<p>配置文件有指令和它们的参数组成。简单的指令是单行组成，以分号结尾。而有些指令是有多个相关联的指令组成，它们用<code>{}</code>包裹起来。</p>
<p>模块功能的实现就是在配置文件给它们提供的指令赋值。</p>
<p>指令还可以写在单独的文件中通过<code>include</code>命令引入主配置文件中。推荐将不同的指令写入不同的文件中，这样便已管理和扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inclued conf.d/http;</span><br><span class="line">include conf.d/stream;</span><br><span class="line">inclued conf.d/exchange-enhanced;</span><br></pre></td></tr></table></figure>
<h3 id="指令上下文"><a href="#指令上下文" class="headerlink" title="指令上下文"></a>指令上下文</h3><p>nginx.conf指令根据其通途是有上下文关系和作用域。<br>顶级指令包含各种指令用来实现功能，顶级指令有：</p>
<ul>
<li>events - 处理连接指令</li>
<li>http - http协议模块</li>
<li>mail - 邮件模块</li>
<li>stream - TCP模块</li>
</ul>
<p>一些Nginx服务配置的指令不属于这些顶级指令，和它们同级写在<strong>main</strong> 上下文。</p>
<p>main上下文包含指令：</p>
<ul>
<li>user - 使用用户名</li>
<li>worker_processes - work进程数，默认是CPU核数</li>
<li>error_log - 错误日志位置</li>
<li>events</li>
<li>http</li>
<li>mail</li>
</ul>
<p>http上下文中包含的指令有：</p>
<ul>
<li>server - 一个域名或IP请求处理方式</li>
<li>sendfile  - 开启快速传输</li>
<li>mail上下文包含指令有：</li>
<li>server - 一个邮件服务</li>
<li>auth_http</li>
<li>imap_capabilities</li>
</ul>
<p>server上下文包含指令：</p>
<ul>
<li>listen - 监听端口</li>
<li>server_name - 服务域名</li>
<li>access_log 交互日志存放地址</li>
<li>location - 同个域名或IP不同地址处理配置</li>
<li>proxy</li>
<li>protocol</li>
<li>smtp_auth</li>
<li>xclient</li>
</ul>
<p>location上下文包含指令：</p>
<ul>
<li>index</li>
<li>root</li>
</ul>
<p>配置文件结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">user  nobody; </span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;  </span><br><span class="line">    server &#123;  </span><br><span class="line">        listen          80;  </span><br><span class="line">        server_name     www.linuxidc.com;  </span><br><span class="line">        access_log      logs/linuxidc.access.log main;  </span><br><span class="line">        location / &#123;  </span><br><span class="line">            index index.html;  </span><br><span class="line">            root  /var/www/linuxidc.com/htdocs;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    server &#123;  </span><br><span class="line">        listen          80;  </span><br><span class="line">        server_name     www.Androidj.com;  </span><br><span class="line">        access_log      logs/androidj.access.log main;  </span><br><span class="line">        location / &#123;  </span><br><span class="line">            index index.html;  </span><br><span class="line">            root  /var/www/androidj.com/htdocs;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mail &#123;</span><br><span class="line">    auth_http  127.0.0.1:80/auth.php;</span><br><span class="line">    pop3_capabilities  &quot;TOP&quot;  &quot;USER&quot;;</span><br><span class="line">    imap_capabilities  &quot;IMAP4rev1&quot;  &quot;UIDPLUS&quot;;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen     110;</span><br><span class="line">        protocol   pop3;</span><br><span class="line">        proxy      on;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen      25;</span><br><span class="line">        protocol    smtp;</span><br><span class="line">        proxy       on;</span><br><span class="line">        smtp_auth   login plain;</span><br><span class="line">        xclient     off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>http中常用的优化手段就是使用gzip压缩返回值。但是因为压缩是发生在运行时，所以它会带来很大的处理开销影响性能上面的影响。</p>
<h3 id="ngx-http-gzip-module"><a href="#ngx-http-gzip-module" class="headerlink" title="ngx_http_gzip_module"></a><a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html?&amp;_ga=2.237708736.1787687063.1513838697-516423535.1513838697#gzip" target="_blank" rel="noopener">ngx_http_gzip_module</a></h3><p>NGINX gzip功能是通过<code>ngx_http_gzip_module</code>实现。</p>
<h4 id="gzip-1"><a href="#gzip-1" class="headerlink" title="gzip;"></a>gzip;</h4><p>是否开启 gzip 压缩。</p>
<ul>
<li>格式: gizp on|off;</li>
<li>默认： off</li>
<li>上下文：http、server、location</li>
</ul>
<h4 id="gizp-buffers"><a href="#gizp-buffers" class="headerlink" title="gizp_buffers"></a>gizp_buffers</h4><p>设置压缩返回值的缓存数量和大小。当gzip去压缩返回值时，需要从系统申请内存用于缓存压缩后的值。<br>number表示申请内存数量，size代表大小。</p>
<ul>
<li>格式：gizp_buffers number size;</li>
<li>默认： 32 4K | 16 8K gzip默认申请原文件大小的内存，4K 还是 8K大小取决于系统。</li>
<li>上下文：http、server、location</li>
</ul>
<h4 id="gzip-comp-level"><a href="#gzip-comp-level" class="headerlink" title="gzip_comp_level"></a>gzip_comp_level</h4><p>压缩等级（1-9）。1 压缩最快，9压缩慢但压缩比大。</p>
<ul>
<li>格式：gzip_comp_level level;</li>
<li>默认：gzip_comp_level 1;</li>
<li>上下文：http、server、location</li>
</ul>
<h4 id="gzip-disable"><a href="#gzip-disable" class="headerlink" title="gzip_disable"></a>gzip_disable</h4><p>如果请求<code>User-Agent</code>匹配设定的字段，就不进行压缩。一般用于针对不支持gzip浏览器设定。</p>
<ul>
<li>格式：gzip+disable regex….</li>
<li>默认值：无</li>
<li>上下文：http、server、location</li>
</ul>
<h4 id="gzip-min-length"><a href="#gzip-min-length" class="headerlink" title="gzip_min_length"></a>gzip_min_length</h4><p>设定压缩最小长度的返回值，这个长度从<code>Content-Length</code>字段读取。有些太小的文件无需压缩。</p>
<ul>
<li>格式： gzip_min_length length;</li>
<li>默认值： gzip_min_length 20;</li>
<li>上下文：http、server、location</li>
</ul>
<h4 id="gzip-http-version"><a href="#gzip-http-version" class="headerlink" title="gzip_http_version"></a>gzip_http_version</h4><p>设定压缩最低HTTP版本。</p>
<ul>
<li>格式：gzip_http_version  1.0 | 1.1</li>
<li>默认值：1.1</li>
<li>上下文： http、server、location</li>
</ul>
<h4 id="gzip-proxied"><a href="#gzip-proxied" class="headerlink" title="gzip_proxied"></a>gzip_proxied</h4><p>Nginx作为反向代理的时候启用或关闭gzip。如果启动则在请求和返回值中包含指定的字段。<br>此指令可以包含多个参数。</p>
<ul>
<li><p>格式： gzip_proxied off off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth </p>
<ul>
<li>off - 禁止压缩，忽略其它参数</li>
<li>expired -  启用压缩，如果header头中包含 “Expires” 头信息</li>
<li>no-cache - 启用压缩，如果header头中包含 “Cache-Control:no-cache” 头信息</li>
<li>no-store - 启用压缩，如果header头中包含 “Cache-Control:no-store” 头信息</li>
<li>private - 启用压缩，如果header头中包含 “Cache-Control:private” 头信息</li>
<li>no_last_modified - 启用压缩,如果header头中不包含 “Last-Modified” 头信息</li>
<li>no_etag - 启用压缩 ,如果header头中不包含 “ETag” 头信息</li>
<li>auth - 启用压缩 , 如果header头中包含 “Authorization” 头信息</li>
<li>any - 无条件启用压缩</li>
</ul>
</li>
<li><p>默认：gzip_proxied off</p>
</li>
<li>上下文： http、server、location</li>
</ul>
<h4 id="gzip-types"><a href="#gzip-types" class="headerlink" title="gzip_types"></a>gzip_types</h4><p>匹配MIME类型进行压缩。’*’匹配任意MIME type</p>
<ul>
<li>格式：gzip_types mime-type … | * (0.8.29)</li>
<li>默认值： gzip_types text/html</li>
<li>上下文：http、server、location</li>
</ul>
<h4 id="gzip-vary"><a href="#gzip-vary" class="headerlink" title="gzip_vary"></a>gzip_vary</h4><p>当<code>gzip</code>、<a href="http://nginx.org/en/docs/http/ngx_http_gzip_static_module.html#gzip_static" target="_blank" rel="noopener"><code>gzip_static</code></a>、<a href="http://nginx.org/en/docs/http/ngx_http_gunzip_module.html#gunzip" target="_blank" rel="noopener"><code>gunzip</code></a>指令被激活，是否向头部插入<code>Vary:Accept-Encoding</code>。</p>
<ul>
<li>格式：gzip_vary on|off</li>
<li>默认：gzip_vary off;</li>
<li>上下文：http、server、location</li>
</ul>
<h3 id="ngx-http-gzip-static-module"><a href="#ngx-http-gzip-static-module" class="headerlink" title="ngx_http_gzip_static_module"></a><a href="http://nginx.org/en/docs/http/ngx_http_gzip_static_module.html#gzip_static" target="_blank" rel="noopener">ngx_http_gzip_static_module</a></h3><p>如果传输文件时，是可以进行预压缩将原文件压缩为<code>.gz</code>结尾。这需要使用模块<code>ngx_http_gzip_static_module</code>。</p>
<p>此模块不是默认模块需要在配置编译时做参数<code>--with-http_gzip_static_module</code>传入。</p>
<h4 id="gzip-static"><a href="#gzip-static" class="headerlink" title="gzip_static"></a>gzip_static</h4><p>是否启动文件压缩</p>
<ul>
<li>格式：gzip_static on | off | always(1.3.6)</li>
<li>默认值：gzip_static off;</li>
<li>上下文：http、server、location</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">        gzip on;</span><br><span class="line">        gzip_disable &quot;msie6&quot;;</span><br><span class="line"></span><br><span class="line">        gzip_vary on;</span><br><span class="line">        gzip_proxied any;</span><br><span class="line">        gzip_comp_level 6;</span><br><span class="line">        gzip_buffers 16 8k;</span><br><span class="line">        gzip_http_version 1.1;</span><br><span class="line">        gzip_types *;</span><br><span class="line">        server &#123;</span><br><span class="line">                location ~ ^/assets/ &#123;</span><br><span class="line">                   gzip_static on;</span><br><span class="line">                   expires max;</span><br><span class="line">                   add_header Cache-Control public;</span><br><span class="line">                &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚拟服务器"><a href="#虚拟服务器" class="headerlink" title="虚拟服务器"></a>虚拟服务器</h2><p>通过Nginx虚拟服务器，一台物理服务器可以同时开启多个服务。<br>Nginx虚拟服务有三种配置方式：</p>
<ul>
<li>域名 根据域名来跟踪服务</li>
<li>端口 同一域名不同端口跟踪服务</li>
<li>IP地址+端口 通过IP地址和端口跟踪服务</li>
</ul>
<p>Nginx服务定义在<code>http</code>指令中，具体的服务请求处理方式是在<code>server</code>指令中定义。<br>一个<code>http</code>上下文中可以定义多个<code>server</code>则就创建了多个虚拟服务器。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 1;</span><br><span class="line">events &#123;</span><br><span class="line">	worker_connections 1024; #最大连接数</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">	include mime.types;</span><br><span class="line">	default_type application/octet-stream;</span><br><span class="line">	sendfile on;</span><br><span class="line">	keepalive_timeout 65;</span><br><span class="line">	server &#123;</span><br><span class="line">		listen 80; # 定义监听的IP和端口 </span><br><span class="line">		server_name www.example.com； # 定义域名</span><br><span class="line">		location / &#123;</span><br><span class="line">			root html/www;</span><br><span class="line">			index index.html index.htm index.php;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	server &#123;</span><br><span class="line">		listen 82;</span><br><span class="line">		server_name www.example.com;</span><br><span class="line">		location / &#123;</span><br><span class="line">			root html/admin;</span><br><span class="line">			index index.html index.htm index.php;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	server &#123;</span><br><span class="line">		listen 10.0.0.8:83;</span><br><span class="line">		server_name www.example.com; </span><br><span class="line">		location / &#123;</span><br><span class="line">			root html/www;</span><br><span class="line">			index index.html index.htm index.php;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>server</code>最主要三个指令是<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html?&amp;_ga=2.228091613.1787687063.1513838697-516423535.1513838697#listen" target="_blank" rel="noopener"><code>listen</code></a>、<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html?&amp;_ga=2.228091613.1787687063.1513838697-516423535.1513838697#server_name" target="_blank" rel="noopener"><code>server_name</code></a>、<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html?&amp;_ga=2.194210157.1787687063.1513838697-516423535.1513838697#location" target="_blank" rel="noopener"><code>location</code></a>。</p>
<h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p><code>location</code>指令用于匹配uri进行的处理。一个server可以设置多个location用于处理不同的uri。</p>
<ul>
<li>格式： location [=|~|~*|^~] uri {}</li>
<li>上下文：server、location<br><code>location</code>指令有两种参数形式：前缀字符串或正则表达式。如果某个请求的URI以某个前缀字符串开始，则与改location匹配。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /some/path/ &#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面location前缀字符串将匹配以<code>/some/path/</code><strong>开头</strong>的请求URI，例如 <strong>/some/path/document.html</strong> 但它并不匹配 <strong>/my-site/some/path</strong>。</p>
<p>如果用正则表达式定义 <strong>~*</strong> 表示忽略大小写，<strong>~</strong> 表示不忽略大小写,<strong>\^~</strong> 表示前缀字符串匹配后不做在做这条正则表达式匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.html? &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面lcation是不忽略大小写的正则表达式，它将匹配到URI包含<strong>.html</strong>或<strong>.htm</strong>的请求。</p>
<p>NGINX首先会将URI于location的前缀字符串进行匹配，然后在于正则表达式匹配。正则表达式拥有优先级，除非前缀字符串用<strong>^~</strong>修饰。<br>在匹配的前缀字符串中，NGINX选择其中最长及完整的前缀字符串所对应的location。</p>
<p>常用正则表达式：</p>
<ul>
<li><code>~</code> 匹配区分大小写</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ /js/</span> &#123;</span><br><span class="line">    //如果是JS大写的是不会匹配到的   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>~</code> 匹配不区分大小写</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* /js/</span> &#123;</span><br><span class="line">    //JS大写或者小写都可以匹配到   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>^</code> 匹配字符串的开始标识</li>
<li><code>$</code> 匹配字符串的结束标识</li>
<li><code>.</code> 点符号匹配除换行符以外的任意字符</li>
<li><code>*</code> 重复零次或更多次 <code>+</code> 重复一次或更多次 <code>?</code> 重复零次或一次</li>
<li><code>^~</code>注意: Nginx将在这个字符串匹配后停止进行正则表达式的匹配（location指令中正则表达式的匹配的结果优先使用） ,一般这种情况用来匹配目录</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /img/ &#123;</span><br><span class="line">     // 这个则匹配的目录, 当匹配到此规则即可终止往下匹配</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.(gif|jpg|jpeg)<span class="variable">$&#123;</span></span></span><br><span class="line"><span class="regexp"><span class="variable">    // 这个规则则是访问的具体的文件 , 如xxxx.jpg等</span></span></span><br><span class="line"><span class="regexp"><span class="variable">&#125;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>=</code>精确匹配</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> = / &#123;</span><br><span class="line">     // 指定某一个规则进行精确的匹配 ,只能匹配" / "</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span>  / &#123;</span><br><span class="line">     // 这个进行全部匹配</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@</code>定义一个命名的 location，使用在内部定向时使用</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 例如出现异常400等 ,可以直接跳转到 单独定义的异常处理的location</span><br><span class="line"><span class="attribute">error_page</span> <span class="number">404</span> = <span class="variable">@fetch</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="variable">@fetch</span>(</span><br><span class="line">   proxy_pass http://fetch;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>[^x]</code>匹配除了x以外的任意字符 , <code>[^abcde</code>] 匹配除了abcde这几个字母以外的任意字符</p>
<p><code>[/]</code> 这个匹配所有的</p>
</li>
</ul>
<p>查找location过程：</p>
<ol>
<li>将URI与所有前缀字符串进行比较</li>
<li>修饰符 <code>=</code> 表示与前缀字符串必须精确匹配。如果能够精确匹配，则结束查找。</li>
<li>如果在匹配的最长的前缀字符串前添加了<code>^~</code>修饰符，则不会再检查正则表达式。</li>
<li>保存匹配的最长的前缀字符串。</li>
<li>测试URI和正则表达式的匹配情况。</li>
<li>^~ 则只匹配该规则，nginx停止搜索其他匹配，否则nginx会继续处理其他location指令。<br>最后匹配理带有”~”和”~*”的指令，如果找到相应的匹配，则nginx停止搜索其他匹配；当没有正则表达式或者没有正则表达式被匹配的情况下，那么匹配程度最高的逐字匹配指令会被使用。</li>
</ol>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html?&amp;_ga=2.228091613.1787687063.1513838697-516423535.1513838697#root" target="_blank" rel="noopener">root</a></h3><p>为require请求设置root目录。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /i/ &#123;</span><br><span class="line">	root /data/w3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 <strong>/data/w3/i/top.gif</strong> 会作为 <strong>/i/top.gif</strong> 请求的返回值。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在 <strong>nginx.conf</strong> 配置文件可以使用变量。变量的值在运行时进行计算。可作为指令的参数使用。<br>变量用 <strong>$</strong>符号开头。<br>许多变量时 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#variables" target="_blank" rel="noopener"><strong>core HTTP</strong></a> 定义好了。你也可以通过 <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#set" target="_blank" rel="noopener"><code>set</code></a>、<a href="http://nginx.org/en/docs/http/ngx_http_map_module.html#map" target="_blank" rel="noopener"> <code>map</code></a>、<a href="http://nginx.org/en/docs/http/ngx_http_geo_module.html#geo" target="_blank" rel="noopener"><code>geo</code></a>指令进行变量自定义</p>
<h3 id="返回指定状态码"><a href="#返回指定状态码" class="headerlink" title="返回指定状态码"></a>返回指定状态码</h3><p>一些requireURIs需要立即返回状态码或重定向。这时就可以通过<code>return</code>指令来完成。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /wrong/url &#123;</span><br><span class="line">	return 404;</span><br><span class="line">&#125;</span><br><span class="line">location /permanently/moved/url &#123;</span><br><span class="line">	return 301 http://www.example.com/moved/here;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="return"><a href="#return" class="headerlink" title="return"></a><a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html?&amp;_ga=2.135465329.1787687063.1513838697-516423535.1513838697#return" target="_blank" rel="noopener">return</a></h4><p>停止处理返回指定的状态给客户端。</p>
<ul>
<li>格式： <ul>
<li>return code [text];</li>
<li>return code URL;</li>
<li>return URL;</li>
</ul>
</li>
<li>上下文：server、location、if </li>
</ul>
<p>return 第一个参数时响应码，第二个参数是可选的，可以是重定向的URL(301,302,303和307),或者是放入body的一段文本。</p>
<h3 id="URI重写"><a href="#URI重写" class="headerlink" title="URI重写"></a>URI重写</h3><p>通过使用<a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html?&amp;_ga=2.227739357.1787687063.1513838697-516423535.1513838697#rewrite" target="_blank" rel="noopener"><code>rewrite</code></a>指令，可以一个requireURI能够被编辑多次在一次请求过程中。</p>
<ul>
<li>格式：rewrite regex replacement [tag]</li>
<li>上下文：server、location、if</li>
</ul>
<p><code>rewrite</code>指令使用需要至少接收两个参数，第一个参数是匹配URI中字符串的正则表达式，第二个参数是代替匹配到的URI字符串。第三个参数是可选的，用于终止进一步的<code>rewrite</code>操作，或者发送重定向（301或302）给客户端。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /users/ &#123;</span><br><span class="line">    rewrite ^/users/(.*)$ /show?user=$1 break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>tag</strong> 值有这些：</p>
<ul>
<li>last - 不在执行后面rewrite指令，立即匹配新地址的location,如果匹配到的location有rewrite指令可以继续处理。</li>
<li>break - 不在执行后面rewrite指令，立即匹配新地址的location,如果匹配到的location有rewrite指令可也不再处理。</li>
<li>redirect - 返回302临时重定向，浏览器地址栏会显示跳转后的URL地址。如果替换的不是<strong>http://</strong>、<strong>https://</strong>、<strong>$scheme</strong>开始。</li>
<li>permanent - 返回一个永久的301重定向，浏览器地址栏会显示跳转后的URL地址。</li>
</ul>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>通过<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html?&amp;_ga=2.195823340.1787687063.1513838697-516423535.1513838697#error_page" target="_blank" rel="noopener"><code>error_page</code></a>指令，你可以配置NGINX给错误状态码返回定制页，或替换返回值中的错误码，或发送重定向指令给浏览器，指向不同的URl地。</p>
<ul>
<li>格式： error_page code …[=[response]] uri</li>
<li>上下文： http、server、location、if in location</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html</span><br></pre></td></tr></table></figure>
<p>上面例子中，<strong>error_page</strong> 指令指定了/404.html页面和404状态码一起返回给客户端。<br>要注意的是，这个指令不是立即返回该错误给客户端（这是 return 指令做的事），这只是定义了如果处理该错误。该 error code 可来自于一个后端服务器，或者在 nginx 做一些处理时出现（例如，当 nginx 不能找到请求的文件时，将返回 404 错误）。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /old/path.html &#123;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> =<span class="number">301</span> http:/example.com/new/path.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>error_page</strong> 可以改变来有错误状态码，上面例子中，code 404替换成code 301并返回一个重定向地址给客户端。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">location</span> /images/ &#123;</span><br><span class="line">        <span class="comment"># Set the root directory to search for the file</span></span><br><span class="line">        <span class="attribute">root</span> /data/www;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Disable logging of errors related to file existence</span></span><br><span class="line">        <span class="attribute">open_file_cache_errors</span> <span class="literal">off</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># Make an internal redirect if the file is not found</span></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> = /fetch<span class="variable">$uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> /fetch/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果在 <strong>/image/some/file</strong>没有找到，它会替换成 <strong>/fetch/images/some/file</strong> 这个新URI，NGNIX会查找新URI匹配的location。</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>用户A访问服务器B，服务B根据请求的地址设置的location将请求转发给服务器C。<br>服务C接收到请求后，将响应返回给服务器B，服务器B最后将响应发送给用户A。<br>从用户A来看，他请求的是服务器B，但实际上处理他请求的是服务C。这就是反向代理。发起者不知道实际处理他请求的是谁。<br><img src="https://i.loli.net/2018/11/05/5bdfdfc13a20b.jpg" alt=""></p>
<p>Nginx除了支持HTTP代理外，还支持<a href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html?_ga=2.249292167.1883161290.1514164498-516423535.1513838697" target="_blank" rel="noopener"><code>FastCGI</code></a>、<a href="http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html?_ga=2.249292167.1883161290.1514164498-516423535.1513838697" target="_blank" rel="noopener"><code>uwsgi</code></a>、<a href="http://nginx.org/en/docs/http/ngx_http_scgi_module.html?_ga=2.218885401.1883161290.1514164498-516423535.1513838697" target="_blank" rel="noopener"><code>SCGI</code></a>、<a href="http://nginx.org/en/docs/http/ngx_http_memcached_module.html?_ga=2.218885401.1883161290.1514164498-516423535.1513838697" target="_blank" rel="noopener"><code>memcached</code></a>。这里只讲HTTP代理配置。</p>
<h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html?&amp;_ga=2.260301453.1883161290.1514164498-516423535.1513838697#proxy_pass" target="_blank" rel="noopener">proxy_pass</a></h3><p><code>proxy_pass</code>指令定义再location中，指定需要代理的HTTP服务器。</p>
<ul>
<li>格式：proxy_pass URL;</li>
<li>上下文：location、if in location,limit_except</li>
</ul>
<p>URL包含代理服务器协议和地址，也可包含端口号。如果包含有URI，这location匹配的URI会被代理URI替换掉。例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /some/path/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://www.example.com/link/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求的URI为： <strong>/some/path/pag.html</strong> ，它与location匹配部分为 <strong>/some/paht</strong> ,这部分会被 <strong>/link/ 替换掉。因此转发给代理服务器地址是： </strong><a href="http://www.example.com/link/page.html_" target="_blank" rel="noopener">http://www.example.com/link/page.html_</a>_ 。</p>
<p>如果<code>proxy_pass</code>没有指定URI，请求URI将以原始请求处理时的客户端发送的相同形式传递给服务器，如果有修改则将修改后的URI传给服务器。</p>
<p>下面情况下，不确定被替换的请求URI是那部分：</p>
<ol>
<li>当location被正则表达式指定，并在location内部时。这种情况下<code>prox_pass</code>不应该指定URI。</li>
<li>当URI在location内部被<code>rewrite</code>修改，这是<code>rewrite</code>应该用 <code>break</code>标记处理。</li>
<li>当<code>proxy_pass</code>上有变量时，则用指令指定的URI替换原来的URI。</li>
</ol>
<h3 id="proxy-http-version"><a href="#proxy-http-version" class="headerlink" title="proxy_http_version"></a>proxy_http_version</h3><p>指定代理请求的HTTP协议。</p>
<ul>
<li>格式： proxy_http_version 1.0 | 1.1</li>
<li>默认值： proxy_http_version 1.0</li>
<li>上下文：http, server,location</li>
</ul>
<p>如果默认值设为1.1，需要和<a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive" target="_blank" rel="noopener"><code>keepalive</code></a>一起使用。例如：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> http_backend &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive</span> <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /http/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://http_backend;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header"></a>proxy_set_header</h3><p>允许重新定义或添加发往后端服务器的请求头。</p>
<ul>
<li>格式： proxy_set_header field value;</li>
<li>默认值： <ul>
<li>proxy_set_header Host $proxy_host;</li>
<li>proxy_set_header Connection close;</li>
</ul>
</li>
<li>上下文：http、server、location</li>
</ul>
<p>对于请求转发，Nginx默认会修改头部两个字段: <strong>Host</strong> 和 <strong>Connection</strong> 。<br><strong>Host</strong> 字段会被设置为 <strong>$proxy_host</strong> （后端服务器地址和端口）变量值。 <strong>Connection</strong> 字段会被设置为 close。<br>如果某个字段值被设为空字符串，该字段将被删除。</p>
<p>如果你不想修改 <strong>Host</strong> 值，可以这么设置：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_set_header</span> Host       <span class="variable">$http_host</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是，如果客户端请求头中没有携带这个头部，那么传递到后端服务器的请求也不含这个头部。 这种情况下，更好的方式是使用$host变量——它的值在请求包含“Host”请求头时为“Host”字段的值，在请求未携带“Host”请求头时为虚拟主机的主域名<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_set_header</span> Host       <span class="variable">$host</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="proxy-buffers"><a href="#proxy-buffers" class="headerlink" title="proxy_buffers"></a>proxy_buffers</h3><p>nginx 从后端服务器获得响应后，默认会将其缓存起来。响应报文被存储在内部缓存中，直到客户端接收完整个报文。使用缓存可以提高 nginx 的代理性能。当遇到某些客户端接收数据的速度较慢时，如果 nginx 将响应报文同步的转发给客户端，这会浪费 nginx 的时间。而启用缓存之后，nginx 可更快速的处理来自后端服务器的响应报文。等客户端接收完成，nginx 就可以删除缓存的响应报文。</p>
<p><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html?&amp;_ga=2.260301453.1883161290.1514164498-516423535.1513838697#proxy_buffers" target="_blank" rel="noopener">proxy_buffers</a>,为每个链接设置缓存数量和大小。</p>
<ul>
<li>格式： proxy_buffers number size;</li>
<li>默认值： proxy_buffers 8 4k|8k</li>
<li>上下文：http、server、lcoation</li>
</ul>
<p>为每个连接设置缓冲区的数量为number，每块缓冲区的大小为size。这些缓冲区用于保存从被代理的服务器读取的响应。每块缓冲区默认等于一个内存页的大小。这个值是4K还是8K，取决于平台。</p>
<h3 id="proxy-buffer-size"><a href="#proxy-buffer-size" class="headerlink" title="proxy_buffer_size"></a><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html?&amp;_ga=2.260301453.1883161290.1514164498-516423535.1513838697#proxy_buffer_size" target="_blank" rel="noopener">proxy_buffer_size</a></h3><p>指令负责设置接收第一部分响应报文的缓存的大小。</p>
<ul>
<li>格式：proxy_buffer_size size;</li>
<li>默认值： proxy_buffer 4k|8k;</li>
<li>上下文：http、server、location</li>
</ul>
<p>设置缓冲区的大小为size。nginx从被代理的服务器读取响应时，使用该缓冲区保存响应的开始部分。这部分通常包含着一个小小的响应头。该缓冲区大小默认等于proxy_buffers指令设置的一块缓冲区的大小，但它也可以被设置得更小。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>当访问量很大一台机器已经无法支持，我们可以部署多台机器做支持。用户的请求被那台服务器由NGINX来分配。这个分配请求到后面服务器的技术就是负载均衡。和反向代理类式。</p>
<h3 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a><a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html?&amp;_ga=2.179505572.1883161290.1514164498-516423535.1513838697#upstream" target="_blank" rel="noopener">upstream</a></h3><p>一组服务器定义在 upstream指令大括号中。服务器可以监听不同的端口。而且，监听在TCP和UNIX域套接字的服务器可以混用。</p>
<ul>
<li>格式： upstream name {…}</li>
<li>上下文：http</li>
</ul>
<p>例子：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    	<span class="attribute">upstream</span> backend &#123;</span><br><span class="line">        	<span class="attribute">server</span> backend1.example.com weight=<span class="number">5</span>;</span><br><span class="line">        	<span class="attribute">server</span> backend2.example.com;</span><br><span class="line">        	<span class="attribute">server</span> <span class="number">192.0.0.1</span> backup;</span><br><span class="line">    	&#125;</span><br><span class="line">	<span class="section">server</span> &#123;</span><br><span class="line">		<span class="attribute">location</span> / &#123;</span><br><span class="line">			<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码所示，<code>upstream</code>中定义了一组服务器，当有请求被定义在<code>server</code>中的<code>location</code>匹配到时会被代理<code>proxy_pass</code>指令中声明的<code>upstream</code>名字，转向 定义好的<code>upstream</code>中。</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>定义服务器地址(address)和其它参数（parameters）。</p>
<ul>
<li>格式： server address [parameters]</li>
<li>上下文：upstream</li>
</ul>
<p>地址可以时域名或IP地址，端口是可选的。或者指定”unix:”前缀的UNIX域套接字的路径。<br>参数有如下：</p>
<ul>
<li>weight=number 设定服务器的权重。默认是1。权重越高被分配的概率越大</li>
<li>max_fails=number 设定NGINX与服务器通信失败尝试的次数。在fail_timeout参数定义的时间段内，如果失败次数达到此值，NGINX会认为此服务器不可用。在下一个fail_timeout时间段，服务器不会再被尝试。失败的尝试次数默认值是1。设为0就会停止统计尝试次数，认为服务器一直可用。</li>
<li>faile_timeout=time  （10s）<ul>
<li>统计失败尝试次数的时间段。这个时间段中，服务器失败次数达到指定的尝试次数，服务器就被认为不可用。</li>
<li>服务器被认为不可用的时间段。</li>
</ul>
</li>
<li>backup 标记服务器为备用。当主服务器不可用后，请求才会被传给这些服务器。</li>
<li>down 标记服务器不永久不可用，可以个<code>ip_hash</code>一起使用。</li>
</ul>
<p>例子：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com     weight=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>           max_fails=<span class="number">3</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    <span class="attribute">server</span> unix:/tmp/backend3;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server</span> backup1.example.com:<span class="number">8080</span> backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h3><p>指定服务器组的负载均衡方法，请求基于客户端的IP地址在服务器间进行分发。 </p>
<ul>
<li>格式：ip_hash</li>
<li>上下文： upstream</li>
</ul>
<p>IPv4地址的前三个字节或者IPv6的整个地址，会被用来作为一个散列key。 这种方法可以确保从同一个客户端过来的请求，会被传给同一台服务器。除了当服务器被认为不可用的时候，这些客户端的请求会被传给其他服务器，而且很有可能也是同一台服务器。<br>很多时候我们需要一个客户只访问一个服务器，那么就需要用ip_hash了，ip_hash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> test &#123;</span><br><span class="line">      ip_hash;</span><br><span class="line">      <span class="attribute">server</span> localhost:<span class="number">8080</span>;</span><br><span class="line">      <span class="attribute">server</span> localhost:<span class="number">8081</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="least-conn"><a href="#least-conn" class="headerlink" title="least_conn"></a>least_conn</h3><p>指定服务器组负载均衡的方法，根据其权重值，将请求发送给活跃连接数量最少的那台服务器。如果这样的服务器有多台，那就采取权重的轮询方法进行尝试。</p>
<ul>
<li>格式： least_conn;</li>
<li>上下文：upstream;</li>
</ul>
<h3 id="least-time"><a href="#least-time" class="headerlink" title="least_time"></a>least_time</h3><p>指定服务器负载均衡的方法，其中请求被传递给服务器的平均响应时间最少，活动连接数最少，同时考虑到服务器的权重。如果这样服务器有多台，就采取权重轮询的方法进行尝试。</p>
<ul>
<li>格式： least_time header | last_byte [inflight];</li>
<li>上下文：upstream</li>
<li>本版：1.7.10</li>
</ul>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>指定服务器负载均衡的方法。根据提供的key值进行客户端和服务器映射产生联系。</p>
<ul>
<li>格式：hash key [consistent];</li>
<li>默认值：upstream</li>
<li>版本：1.7.2</li>
</ul>
<p><strong>key</strong> 值可以是文本也可以是变量。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend &#123; </span><br><span class="line">       <span class="attribute">hash</span> <span class="variable">$request_uri</span>; </span><br><span class="line">       <span class="attribute">hash_method</span> crc32; </span><br><span class="line">       <span class="attribute">server</span> localhost:<span class="number">8080</span>;</span><br><span class="line">       <span class="attribute">server</span> localhost:<span class="number">8081</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="静态内容服务"><a href="#静态内容服务" class="headerlink" title="静态内容服务"></a>静态内容服务</h2><p>作为一个WEB服务器，NGINX有个很重要任务是将静态文件发送给客户端。而静态文件的路径，和性能优化是基础。</p>
<h3 id="root-1"><a href="#root-1" class="headerlink" title="root"></a><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#root" target="_blank" rel="noopener">root</a></h3><p>为请求设置根目录。</p>
<ul>
<li>格式：root path;</li>
<li>默认值 root html;</li>
<li>上下文：http、server、location、if in location。</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /i/ &#123;</span><br><span class="line">	<span class="attribute">root</span> /data/w3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，如果请求路径是 <strong>/i/top.gif</strong> 则NGINX查找文件路径将是 <strong>/data/w3/i/top.gif</strong> 。</p>
<h3 id="try-file"><a href="#try-file" class="headerlink" title="try_file"></a><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#try_files" target="_blank" rel="noopener">try_file</a></h3><p>try_files 指令用于检测指定的文件或目录是否存在，如果不存在，就做内部重定向，或者返回指定的状态码。</p>
<ul>
<li>格式：<ul>
<li>try_files file … uri;</li>
<li>try_files file … =code;</li>
</ul>
</li>
<li>上下文：server、location</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">root</span> /www/data;</span><br><span class="line">	<span class="attribute">location</span> /images/ &#123;</span><br><span class="line">		<span class="attribute">try_files</span> <span class="variable">$uri</span> /images/default.gif;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码，如果请求URI是 <strong>/images/top.gif</strong> 而这个文件不存在， try_files指令会将原来的URI重定向到 <strong>/images/default.gif</strong> 。NGINX进行重新路径匹配，最后返回 <strong>/www/data/images/default.gif</strong>文件。</p>
<p><strong>try_files</strong> 指令最后参数可以是一个状态码或一个 locationde 名字。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">	<span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">$uri</span>.html =<span class="number">404</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中，如果 try_files指令的所有参数都没解析一个存在的文件或目录那么就返回404错误。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">	<span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@backend</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> <span class="variable">@backend</span> &#123;</span><br><span class="line">	<span class="attribute">proxy_pass</span> http://backend.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码，如果原始URI,以及URI/不能解析为一个存在的文件或目录，该请求将被重定向到一个命名的 location,该location将请求转发给后端服务器。</p>
<h3 id="autoindex"><a href="#autoindex" class="headerlink" title="autoindex"></a><a href="http://nginx.org/en/docs/http/ngx_http_autoindex_module.html#autoindex" target="_blank" rel="noopener">autoindex</a></h3><p>是否将文件列出。</p>
<ul>
<li>格式： autoindex on|off</li>
<li>默认值：autoindex off;</li>
<li>上下文：http、server、location</li>
</ul>
<h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#sendfile" target="_blank" rel="noopener">sendfile</a></h3><p>默认情况下，NGINX再进行文件发送前会将文件拷贝进缓存。通过开启<code>sendfile</code>，可以取消这一步。而是直接将文件拷贝到另外一个。</p>
<ul>
<li>格式： sendfile on | off;</li>
<li>默认值：sendfile off;</li>
<li>上下文：http、server、location、if in location</li>
</ul>
<h3 id="sendfile-max-chunk"><a href="#sendfile-max-chunk" class="headerlink" title="sendfile_max_chunk"></a><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#sendfile_max_chunk" target="_blank" rel="noopener">sendfile_max_chunk</a></h3><p>为了阻止一个快速连接完全占用worker进程，可限制单个<code>sendfile()</code>调用时可以传递的数据大小。</p>
<ul>
<li>格式： sendfile_max_chunk size;</li>
<li>默认值：sendfile_max_chunk 0;</li>
<li>上下文：http、server、location。</li>
</ul>
<h3 id="tcp-nopush"><a href="#tcp-nopush" class="headerlink" title="tcp_nopush"></a><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#tcp_nopush" target="_blank" rel="noopener">tcp_nopush</a></h3><p>开启或关闭使用 <strong>TCP_NODELAY</strong> 操作再 FreeBSD中。或 TCP_CORK 套接字操作在Linux。<br>这个操作只能与 <code>sendfile</code>一起使用。</p>
<ul>
<li>格式： tcp_nopush on | off;</li>
<li>默认值：tcp_nopush off;</li>
<li>上下文：http、server、location</li>
</ul>
<p>开启影响有下面两个：</p>
<ul>
<li>在Linux和FreeBSD 4.*上将响应头和正文的开始部分一起发送；</li>
<li>一次性发送整个文件。</li>
</ul>
<h3 id="tcp-nodelay"><a href="#tcp-nodelay" class="headerlink" title="tcp_nodelay"></a><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#tcp_nodelay" target="_blank" rel="noopener">tcp_nodelay</a></h3><p>tcp_nodelay操作允许覆盖<a href="https://en.wikipedia.org/wiki/Nagle&#39;s_algorithm" target="_blank" rel="noopener">Nagle’s algorithm</a>算法。这个算法目的是当解决在低网速发送小数据报文的问题。该算法将一定量的小报文整合为一个大数据报文，并以200ms延迟发送。现在网络情况下，当提供很大一个静态文件时，可以无需在意报文的大小，可以立即发送数据报文。</p>
<ul>
<li>格式： tcp_nodelay on | off;</li>
<li>默认值： tcp_nodelay on;</li>
<li>上下文：http、server、location</li>
</ul>
<p>该选项仅在连接转换到保持活动状态时启用。例如：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /mp3  &#123;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>       <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="优化Backlog-队列"><a href="#优化Backlog-队列" class="headerlink" title="优化Backlog 队列"></a>优化Backlog 队列</h3><p>NGINX很重要一个特点是可以快速处理进来的连接。<br>一般的规则是当一个连接被确认，它会加入监听的监听套接字 <strong>listen</strong> 队列。正常情况下这个队列会很小，或者没有。但在高负荷下，这个队列可能显著增长这样的结果就是性能不均衡，连接丢失和延迟。</p>
<h4 id="查看-Listen-队列"><a href="#查看-Listen-队列" class="headerlink" title="查看 Listen 队列"></a>查看 Listen 队列</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat</span> -Lan</span><br></pre></td></tr></table></figure>
<p>正常情况是这样：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Current</span> listen queue sizes (qlen/incqlen/maxqlen)</span><br><span class="line">Listen         Local Address         </span><br><span class="line"><span class="number">0</span>/<span class="number">0</span>/<span class="number">128</span>        *.<span class="number">12345</span>            </span><br><span class="line"><span class="number">10</span>/<span class="number">0</span>/<span class="number">128</span>        *.<span class="number">80</span>       </span><br><span class="line"><span class="number">0</span>/<span class="number">0</span>/<span class="number">128</span>        *.<span class="number">8080</span></span><br></pre></td></tr></table></figure></p>
<p>上面输出显示，在80端口有10个未接收的请求。它连接限制是128个。这是正常的情况。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Current</span> listen queue sizes (qlen/incqlen/maxqlen)</span><br><span class="line">Listen         Local Address         </span><br><span class="line"><span class="number">0</span>/<span class="number">0</span>/<span class="number">128</span>        *.<span class="number">12345</span>            </span><br><span class="line"><span class="number">192</span>/<span class="number">0</span>/<span class="number">128</span>        *.<span class="number">80</span>       </span><br><span class="line"><span class="number">0</span>/<span class="number">0</span>/<span class="number">128</span>        *.<span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>在高负载情况下，输出如上显示。有192个连接未被接收这超过了限制的128个连接。这时你需要增加等待队列的上限值。这需要我们调整操作系统的参数已经NGINX的配置参数。</p>
<h4 id="FreeBSD"><a href="#FreeBSD" class="headerlink" title="FreeBSD"></a>FreeBSD</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> sysctl kern.ipc.somaxconn=<span class="number">4096</span></span><br></pre></td></tr></table></figure>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> sysctl -w net.core.somaxconn=<span class="number">4096</span></span><br><span class="line"></span><br><span class="line">打开 /etc/sysctl.conf 文件</span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">添加一行内容如下：</span><br><span class="line">net.core.somaxconn = <span class="number">4096</span></span><br></pre></td></tr></table></figure>
<h4 id="配置NGINX"><a href="#配置NGINX" class="headerlink" title="配置NGINX"></a>配置NGINX</h4><p>如果你设置的 <strong>somaxconn</strong>值大于512值，你需要修改 listen指令的 backlog参数。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> backlog <span class="number">4096</span>;</span><br><span class="line">    <span class="comment"># The rest of server configuration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><h3 id="日志分析工具-goaccess"><a href="#日志分析工具-goaccess" class="headerlink" title="日志分析工具 goaccess"></a>日志分析工具 <a href="https://goaccess.io/" target="_blank" rel="noopener">goaccess</a></h3><p>goaccess是一个专业的实时日志分析工具，是用c语言写的，功能强大，能分析nginx，apache等日志。它能够分析访问的来源，访问所有的浏览器，操作系统，它的统计信息不输于一个专业的浏览量统计网站，而且它还能导出成csv、html等格式。</p>
<h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://tar.goaccess.io/goaccess-1.2.tar.gz</span><br><span class="line">$ tar -xzvf goaccess-1.2.tar.gz</span><br><span class="line">$ cd goaccess-1.2/</span><br><span class="line">$ ./configure --enable-utf8 --enable-geoip=legacy</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>客户端输出：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">goaccess</span> access.log -c</span><br></pre></td></tr></table></figure></p>
<p>静态页面输出：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">goaccess</span> access.log -o report.html --log-format=COMBINED</span><br></pre></td></tr></table></figure></p>
<p>实时静态页输出：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">goaccess</span> access.log -o /var/www/html/report.html --log-format=COMBINED --real-time-html</span><br></pre></td></tr></table></figure></p>
<h3 id="日志切割"><a href="#日志切割" class="headerlink" title="日志切割"></a>日志切割</h3><p>通过 logrotate服务完成日志切割。<br>编辑 __/etc/logrotate.d/nginx这个文件<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/var/log/nginx/*.log &#123;</span><br><span class="line">    weekly</span><br><span class="line">    missingok</span><br><span class="line">    <span class="attribute">rotate</span> <span class="number">52</span></span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    notifempty</span><br><span class="line">    create <span class="number">0640</span> www-data adm</span><br><span class="line">    sharedscripts</span><br><span class="line">    prerotate</span><br><span class="line">        if [ -d /etc/logrotate.d/httpd-prerotate ]; <span class="attribute">then</span> \</span><br><span class="line">            run-parts /etc/logrotate.d/httpd-prerotate; \</span><br><span class="line">        <span class="attribute">fi</span> \</span><br><span class="line">    endscript</span><br><span class="line">    postrotate</span><br><span class="line">        [ -s /var/run/nginx.pid ] &amp;&amp; kill -USR1 `cat /var/run/nginx.pid`</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在线升级-编译模块"><a href="#在线升级-编译模块" class="headerlink" title="在线升级/编译模块"></a>在线升级/编译模块</h2><p>因为NGINX一主多work进程架构，升级或编译新模块及其简单。和安装基本一样</p>
<ol>
<li>./configure </li>
<li>make</li>
<li>make install</li>
<li>make upgrade</li>
</ol>
<p>需要新编译自带模块就在 <code>configure</code>时加入例如：<code>--without-http_fastcgi_module</code>。<br>如果安装第三方模块，先将模块下载下来，然后通过<code>--add-module=第三方模块绝对路径</code>引入<code>./configure</code>中</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://fynn90.github.io">Fynn</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://fynn90.github.io/2017/12/25/Nginx入门指南/">https://fynn90.github.io/2017/12/25/Nginx入门指南/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
  <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden />
    <label class="reward-button" for="reward">赞赏支持</label>
    <div class="qr-code">
      
      
        <label class="qr-code-image" for="reward">
          <img class="image" src="/image/reward/wechat.png" title="wechat">
        </label>
      
      
        <label class="qr-code-image" for="reward">
          <img class="image" src="/image/reward/alipay.png" title="alipay">
        </label>
      
    </div>
  </div>

    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Nginx/">Nginx</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/01/07/MySQL基础操作手册/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">MySQL基础操作指南</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2017/12/15/python-logging /">
        <span class="next-text nav-default">Python-Logging</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:fynn.90@outlook.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.linkedin.com/in/%E5%B8%86-%E9%82%93-17163589/" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
        
          <a href="https://plus.google.com/u/0/117459332873536225443" class="iconfont icon-google" title="google"></a>
        
      
    
      
        
          <a href="https://github.com/fynn90" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="http://www.weibo.com/306019091" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
        
          <a href="https://www.zhihu.com/people/FynnDeng/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Fynn</span>
  </span>
  
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
