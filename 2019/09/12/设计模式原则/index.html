<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="面向对象设计模式原则"/>




  <meta name="keywords" content="设计模式原则, Fynn's Blog" />










  <link rel="alternate" href="/atom.xml" title="Fynn's Blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="https://fynn90.github.io/2019/09/12/设计模式原则/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?607980a031d3edcefed502ce80e77ffb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <script id="google_analytics">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-115728733-1', 'auto');
        ga('send', 'pageview');
  </script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "jH321kB4p1r5FNrL8YBCwbrG-gzGzoHsz",
      appKey: "Q8vnaBtTzmVPbVX8tdzM7z7w"
    });
  </script>





    <title> 面向对象设计模式原则 - Fynn's Blog </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Fynn's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/categories/">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Fynn's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            
            
              分类
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          面向对象设计模式原则
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-09-12
        </span>
        
          <div class="post-category">
            
              <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"
             data-title="面向对象设计模式原则">
            阅读次数
          </div>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%88Single-Responsibility-Principle-SRP%EF%BC%89"><span class="toc-text">单一职责原则（Single Responsibility Principle, SRP）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88Open-Closed-Principle%EF%BC%8COCP%EF%BC%89"><span class="toc-text">开闭原则（Open Closed Principle，OCP）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88Liskov-Substitution-Principle%EF%BC%8CLSP%EF%BC%89"><span class="toc-text">里氏代换原则（Liskov Substitution Principle，LSP）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%EF%BC%88Dependency-Inversion-Principle%EF%BC%8CDIP%EF%BC%89"><span class="toc-text">依赖倒转原则（Dependency Inversion Principle，DIP）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%88Interface-Segregation-Principle%EF%BC%8CISP%EF%BC%89"><span class="toc-text">接口隔离原则（Interface Segregation Principle，ISP）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%EF%BC%88Law-of-Demeter%EF%BC%8CLOD%EF%BC%89"><span class="toc-text">迪米特法则（Law of Demeter，LOD）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90-%E8%81%9A%E5%90%88%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%88Composite-Aggregate-Reuse-Principle%EF%BC%8CCARP%EF%BC%89"><span class="toc-text">合成&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle，CARP）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88-Aggregate-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">聚合(Aggregate)的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90-Composite-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">合成(Composite)的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%92%8C%E5%90%88%E6%88%90%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">聚合和合成的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%90%88%E6%88%90-%E8%81%9A%E5%90%88%E6%9D%A5%E6%9B%BF%E4%BB%A3%E7%BB%A7%E6%89%BF%E8%BE%BE%E5%88%B0%E5%A4%8D%E7%94%A8%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">为什么要用合成&#x2F;聚合来替代继承达到复用的目的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>设计模式（Design Patterns）：维护、扩展代码的组织形式。它是开发人员对于代码组织方式的总结，每一种设计模式都是针对不同的代码逻辑场景提出最优的代码组织方式。</p>
<p>每个设计模式都会遵循一个或多个设计原则，这些原则有：</p>
<ol>
<li>单一职责原则（Single Responsibility Principle, SRP）</li>
<li>开闭原则（Open Closed Principle，OCP）</li>
<li>里氏代换原则（Liskov Substitution Principle，LSP）</li>
<li>接口隔离原则（Interface Segregation Principle，ISP）</li>
<li>依赖倒转原则（Dependency Inversion Principle，DIP）</li>
<li>迪米特法则（Law of Demeter，LOD）</li>
<li>合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）</li>
</ol>
<table>
<thead>
<tr>
<th align="center">标记</th>
<th align="center">设计模式原则名称</th>
<th align="center">简单定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SRP</td>
<td align="center">单一职责原则</td>
<td align="center">一个类只负责一个功能领域中的相应职责</td>
</tr>
<tr>
<td align="center">OCP</td>
<td align="center">开闭原则</td>
<td align="center">对扩展开放，对修改关闭</td>
</tr>
<tr>
<td align="center">LSP</td>
<td align="center">里氏代换原则</td>
<td align="center">所有引用基类的地方必须能透明地使用其子类的对象</td>
</tr>
<tr>
<td align="center">ISP</td>
<td align="center">接口隔离原则</td>
<td align="center">类之间的依赖关系应该建立在最小的接口上</td>
</tr>
<tr>
<td align="center">DIP</td>
<td align="center">依赖倒转原则</td>
<td align="center">依赖于抽象，不能依赖于具体实现</td>
</tr>
<tr>
<td align="center">LOD</td>
<td align="center">迪米特法则</td>
<td align="center">一个软件实体应当尽可能少的与其他实体发生相互作用</td>
</tr>
<tr>
<td align="center">CARP</td>
<td align="center">合成/聚合复用原则</td>
<td align="center">尽量使用合成/聚合，而不是通过继承达到复用的目的</td>
</tr>
</tbody></table>
<p><em>单一职责原则_、_开闭原则_、_里氏代换原则_、_接口隔离原则</em> 和<em>依赖倒转原则</em> 就是我们平常熟知的<strong>SOLID</strong>。</p>
<span id="more"></span>

<h2 id="单一职责原则（Single-Responsibility-Principle-SRP）"><a href="#单一职责原则（Single-Responsibility-Principle-SRP）" class="headerlink" title="单一职责原则（Single Responsibility Principle, SRP）"></a>单一职责原则（Single Responsibility Principle, SRP）</h2><blockquote>
<p><strong>定义：</strong>一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事。。</p>
</blockquote>
<p>如果<code>职责</code>是针对整个<code>类</code>而言，在<code>Java</code>中一个<code>类</code>会包含很多<code>属性</code>和<code>行为</code>，要达到一个原因影响一个<code>类</code>变更是很难的。除非拆成极端的最细颗粒，但这样维护时间成本会增大。</p>
<p><strong>优点</strong>：</p>
<ol>
<li><p>类的复杂性降低，实现什么职责都有清晰明确的定义；</p>
</li>
<li><p>可读性提高，复杂性降低，那当然可读性提高了；</p>
</li>
<li><p>可维护性提高，可读性提高，那当然更容易维护了；</p>
</li>
<li><p>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个</p>
</li>
<li><p>接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</p>
</li>
</ol>
<p>对于单一职责原则， 我的建议是接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。</p>
<h2 id="开闭原则（Open-Closed-Principle，OCP）"><a href="#开闭原则（Open-Closed-Principle，OCP）" class="headerlink" title="开闭原则（Open Closed Principle，OCP）"></a>开闭原则（Open Closed Principle，OCP）</h2><blockquote>
<p><strong>定义：</strong>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭</p>
</blockquote>
<p>在软件的生命周期内，因为变化、升级和维护等原因，需要对软件原有的代码进行修改时，可能会给旧代码引入错误。因此，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。</p>
<p><strong>优点：</strong></p>
<ol>
<li><p>增加稳定性</p>
</li>
<li><p>可扩展性高</p>
</li>
</ol>
<p>总结：开闭原则是个很抽象感念，也是很虚的概念，它定义简单，但又不简单，我们在一直拥抱变化，试想如何让其保持遵循开闭原则</p>
<p>使用开闭原则需要注意什么：</p>
<ol>
<li><p>开闭只是一个原则，口号实现拥抱变化的方法很多，前提条件是：类必须做到高内聚，低耦合，这样拥抱变化时减少不可预料故障。</p>
</li>
<li><p>项目规章非常重要， 有个稳定的规章，也是所有成员必须遵守的约定，能给我们带来非常多的好处，如提高开发效率，降低缺陷率，减少维护成本等。</p>
</li>
<li><p>预知变化</p>
</li>
</ol>
<h2 id="里氏代换原则（Liskov-Substitution-Principle，LSP）"><a href="#里氏代换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle，LSP）"></a>里氏代换原则（Liskov Substitution Principle，LSP）</h2><blockquote>
<p><strong>定义：</strong> 所有引用基类的地方必须能透明地使用其子类的对象</p>
</blockquote>
<p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类完全可以替代父类，反之不成立，主要为继承量身打造。</p>
<p><strong>继承的好处：</strong></p>
<ol>
<li><p>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；</p>
</li>
<li><p>提高代码的重用性；</p>
</li>
<li><p>子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；</p>
</li>
<li><p>提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；</p>
</li>
<li><p>提高产品或项目的开放性。</p>
</li>
</ol>
<p><strong>继承的缺陷：</strong></p>
<ol>
<li>继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；</li>
<li>降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；</li>
<li>增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。</li>
</ol>
<p>里氏代换原则包含的四层含义：</p>
<ol>
<li><p>子类必须完全实现父类的方法</p>
</li>
<li><p>子类必须完全实现父类的方法。子类可以有自己的方法和属性，相应子类可以胜任父类，但是父类不可以胜任子类</p>
</li>
<li><p>覆盖或者实现父类的方法时输入参数被放大：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;￼</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Collection <span class="title">doSomething</span><span class="params">(HashMap map)</span></span>&#123;￼</span><br><span class="line">		System.out.println(<span class="string">&quot;父类被执行...&quot;</span>);￼</span><br><span class="line">		<span class="keyword">return</span> map.values();￼</span><br><span class="line">	&#125;</span><br><span class="line"> ￼&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;￼</span><br><span class="line">	<span class="comment">//放大输入参数类型￼</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Collection <span class="title">doSomething</span><span class="params">(Map map)</span></span>&#123;￼</span><br><span class="line">		System.out.println(<span class="string">&quot;子类被执行...&quot;</span>);￼</span><br><span class="line">		<span class="keyword">return</span> map.values();￼</span><br><span class="line">	&#125;￼</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>覆写或实现父类的方法时返回结果可以被缩小</p>
<p>当父类返回一个类型 T，子类的相同方法(覆写或重载)返回值为 S，里氏替换原则要求 S 必须小于等于 T，也就是说要么 S 和 T 一个类型，要么 S 是 T 的子集，为什么，在默念这一句话：有父类的地方，子类应该完全胜任。</p>
</li>
</ol>
<h2 id="依赖倒转原则（Dependency-Inversion-Principle，DIP）"><a href="#依赖倒转原则（Dependency-Inversion-Principle，DIP）" class="headerlink" title="依赖倒转原则（Dependency Inversion Principle，DIP）"></a>依赖倒转原则（Dependency Inversion Principle，DIP）</h2><blockquote>
<p><strong>定义：</strong></p>
<ol>
<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li>
<li>抽象不应该依赖细节；</li>
<li>细节应该依赖抽象。</li>
</ol>
</blockquote>
<p>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter 注入）和接口注入。Spring 的 IOC 是此实现的典范。</p>
<p>从 Java 角度看待依赖倒转原则的本质就是：面向接口(抽象)编程。</p>
<ul>
<li>每个具体的类都应该有其接口或者基类，或者两者都具备。</li>
<li>类中的引用对象应该是接口或者基类。</li>
<li>任何具体类都不应该派生出子类。</li>
<li>尽量不要覆写基类中的方法。</li>
<li>结合里氏代换原则使用。</li>
</ul>
<p>遵循依赖倒转原则的一个例子，场景是司机开车：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDriver</span> <span class="keyword">implements</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		car.run();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bmw</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Bmw runs...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Benz runs...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Driver driver = <span class="keyword">new</span> DefaultDriver();</span><br><span class="line">		Car car = <span class="keyword">new</span> Benz();</span><br><span class="line">		driver.setCar(car);</span><br><span class="line">		driver.drive();</span><br><span class="line">		car = <span class="keyword">new</span> Bmw();</span><br><span class="line">		driver.setCar(car);</span><br><span class="line">		driver.drive();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样实现了一个司机可以开各种类型的车，如果还有其他类型的车，只需要新加一个<code>Car</code>的实现即可。</p>
<h2 id="接口隔离原则（Interface-Segregation-Principle，ISP）"><a href="#接口隔离原则（Interface-Segregation-Principle，ISP）" class="headerlink" title="接口隔离原则（Interface Segregation Principle，ISP）"></a>接口隔离原则（Interface Segregation Principle，ISP）</h2><blockquote>
<p><strong>定义：</strong> 客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。</p>
</blockquote>
<p>简单来说就是建立单一的接口，不要建立臃肿庞大的接口。也就是接口尽量细化，同时接口中的方法尽量少。</p>
<p>单一职责原则注重的是类和接口的职责单一，这里职责是从业务逻辑上划分的，但是在接口隔离原则要求当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。也就是说，我们在设计接口的时候有可能满足单一职责原则但是不满足接口隔离原则。</p>
<p><strong>接口隔离原则的规范：</strong></p>
<ul>
<li>使用接口隔离原则前首先需要满足单一职责原则。</li>
<li>接口需要高内聚，也就是提高接口、类、模块的处理能力，少对外发布<code>public</code>的方法。</li>
<li>定制服务，只提供访问者需要的方法。</li>
<li>接口设计是有限度的，接口的设计粒度越小，系统越灵活，但是值得注意不能过小，否则变成”字节码编程”。</li>
</ul>
<h2 id="迪米特法则（Law-of-Demeter，LOD）"><a href="#迪米特法则（Law-of-Demeter，LOD）" class="headerlink" title="迪米特法则（Law of Demeter，LOD）"></a>迪米特法则（Law of Demeter，LOD）</h2><blockquote>
<p><strong>定义：</strong> 一个软件实体应当尽可能少地与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p>
</blockquote>
<p>迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类（中间类或者跳转类）来转达。</p>
<p><strong>包含 3 层含义：</strong></p>
<ol>
<li><p>只有朋友交流</p>
<p>最少朋友思维，不必要和朋友的朋友都认识，只要认识你这个朋友，你的朋友会找到他的朋友帮你办好事。</p>
<p>只对自己必然要联系对象进行关联，不必要的对象减少耦合，不应和过多对象建立关系，如果过多就该考虑如何分出管理了，“尽量做到满身筋骨，而不是肥嘟嘟！”</p>
</li>
<li><p>朋友间应该保持适当距离</p>
<p>即使关联类之间，也应该保持相应“距离”， 不能无所不知，不需要完全暴露所有细节，这就是前面说的高内聚，只提供公共方法，具体实现对外不需要暴露，</p>
<p>注意： 迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的 public 方法和非静态的 public 变量，尽量内敛，多使用 private 访问权限。</p>
</li>
<li><p>自己的还是自己</p>
<p>在实际应用中经常会出现这样一个方法：放在本类中也可以，放在其他类中也没有错，那怎么去衡量呢？你可以坚持这样一个原则：如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。</p>
</li>
</ol>
<p>迪米特法则的核心观念就是类间解耦，也就降低类之间的耦合，只有类处于弱耦合状态，类的复用率才会提高。所谓降低类间耦合，实际上就是尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。</p>
<p>体育老师要知道班里面女生的人数，他委托体育课代表点清女生的人数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupLeader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;Girl&gt; girls;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GroupLeader</span><span class="params">(List&lt;Girl&gt; girls)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.girls = girls;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countGirls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;The sum of girls is &quot;</span> + girls.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">command</span><span class="params">(GroupLeader leader)</span></span>&#123;</span><br><span class="line">		leader.countGirls();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">		GroupLeader groupLeader = <span class="keyword">new</span> GroupLeader(Arrays.asList(<span class="keyword">new</span> Girl(), <span class="keyword">new</span> Girl()));</span><br><span class="line">		teacher.command(groupLeader);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，体育课代表就是中间类，体育课代表对于体育老师来说就是”直接的朋友”，如果去掉体育课代表这个中间类，体育老师必须亲自清点女生的人数(实际上就数人数这个功能，体育老师是不必要获取所有女生的对象列表)，这样做会违反迪米特法则。</p>
<h2 id="合成-聚合复用原则（Composite-Aggregate-Reuse-Principle，CARP）"><a href="#合成-聚合复用原则（Composite-Aggregate-Reuse-Principle，CARP）" class="headerlink" title="合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）"></a>合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）</h2><blockquote>
<p><strong>定义：</strong>尽量使用合成/聚合，而不是通过继承达到复用的目的。</p>
</blockquote>
<p>合成/聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向内部持有的这些对象的委派达到复用已有功能的目的，而不是通过继承来获得已有的功能。</p>
<h3 id="聚合-Aggregate-的概念"><a href="#聚合-Aggregate-的概念" class="headerlink" title="聚合(Aggregate)的概念"></a>聚合(Aggregate)的概念</h3><p>聚合表示一种弱的”拥有”关系，一般表现为松散的整体和部分的关系，其实，所谓整体和部分也可以是完全不相关的。例如 A 对象持有 B 对象，B 对象并不是 A 对象的一部分，也就是 B 对象的生命周期是 B 对象自身管理，和 A 对象不相关。</p>
<h3 id="合成-Composite-的概念"><a href="#合成-Composite-的概念" class="headerlink" title="合成(Composite)的概念"></a>合成(Composite)的概念</h3><p>合成表示一种强的”拥有”关系，一般表现为严格的整体和部分的关系，部分和整体的生命周期是一样的。</p>
<h3 id="聚合和合成的关系"><a href="#聚合和合成的关系" class="headerlink" title="聚合和合成的关系"></a>聚合和合成的关系</h3><p>这里用山羊举例说明聚合和合成的关系：</p>
<p><img src="https://pic.downk.cc/item/5fe3417a3ffa7d37b3d67883.png"></p>
<h3 id="为什么要用合成-聚合来替代继承达到复用的目的"><a href="#为什么要用合成-聚合来替代继承达到复用的目的" class="headerlink" title="为什么要用合成/聚合来替代继承达到复用的目的"></a>为什么要用合成/聚合来替代继承达到复用的目的</h3><p>继承复用破坏包装，因为继承将基类的实现细节暴露给派生类，基类的内部细节通常对子类来说是可见的，这种复用也称为”白箱复用”。这里有一个明显的问题是：派生类继承自基类，如果基类的实现发生改变，将会影响到所有派生类的实现；如果从基类继承而来的实现是静态的，不可能在运行时发生改变，不够灵活。</p>
<p>由于合成或聚合关系可以将已有的对象，一般叫成员对象，纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为”黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成/聚合复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>设计模型和设计原则是从开发实践中总结出来的最有组织代码形式，但在我们自己实际的业务场景中设计原则之间可能会有矛盾处，我们应该灵活使用不要教条主义生搬硬套。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/5hoopguzfyfzd91ldg5g">https://www.infoq.cn/article/5hoopguzfyfzd91ldg5g</a></p>
<p><a target="_blank" rel="noopener" href="https://www.throwable.club/2019/05/05/design-pattern-basic-law/">https://www.throwable.club/2019/05/05/design-pattern-basic-law/</a></p>
<p><a target="_blank" rel="noopener" href="https://thinkkeep.github.io/design-patterns/zh/uml/design-principle.html">https://thinkkeep.github.io/design-patterns/zh/uml/design-principle.html</a></p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://fynn90.github.io">Fynn</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://fynn90.github.io/2019/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/">https://fynn90.github.io/2019/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
  <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden />
    <label class="reward-button" for="reward">赞赏支持</label>
    <div class="qr-code">
      
      
        <label class="qr-code-image" for="reward">
          <img class="image" src="/image/reward/wechat.png" title="wechat">
        </label>
      
      
        <label class="qr-code-image" for="reward">
          <img class="image" src="/image/reward/alipay.png" title="alipay">
        </label>
      
    </div>
  </div>

    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/">设计模式原则</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/09/13/JS_Proxy_and_Reflect/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Proxy、Reflect</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2019/09/10/Object.defineProperty/">
        <span class="next-text nav-default">Object.defineProperty</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:fynn.90@outlook.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/%E5%B8%86-%E9%82%93-17163589/" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
        
          <a target="_blank" rel="noopener" href="https://github.com/fynn90" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a target="_blank" rel="noopener" href="http://www.weibo.com/306019091" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
        
          <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/FynnDeng/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2021

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Fynn</span>
  </span>
  
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
